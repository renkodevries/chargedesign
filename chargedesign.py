r"""

description
***********

does Metropolis Monte Carlo search to find identities of surface residues that 
minimize the fluctuations of average electrostatic potential on the solvent accessible
surface of a symmetric protein multimer. The input multimer structure must already have been 
rosetta optimized such that a symmetrize operation on its first chain (with provided symmetry file)
correctly gives the multimer structure. If inputfile is input/input.json, call as:

.. code-block:: python3

	python chargedesign.py input/input.json

input
*****

Sample inputfile:

.. code-block:: javascript

	{
	"pdb_in" : "pdb/in/M_C3.pdb",
	"pdb_out_folder" : "pdb/out/",
	"pdb_out_prefix" : "_",
	"symm_file" : "sym/c3.symm",
	"charge_file" : "constraints/M_chargeadjust.charge",
	"comp_file" : "constraints/M_chargeadjust.comp",
	"score_file" : "scores/M_chargedesign_scores.txt",
	"designable_residues" : 
	[
	257,258,261,264,265,268,269,272,17,21,25,28,29,31,32,34,38,42,62,65,68,
	72,76,79,83,87,90,93,94,96,103,124,125,127,130,134,138,141,145,149,152,
	155,186,187,189,196,200,203,207,211,214,217,218,219,230,237,241,245,248,
	249,250,251,253,254
	],
	"exclude_residues" : 
	[
	39,  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
	101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
	163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178
	],
	"repack_distance_treshold" : 7.0,
	"n_mutate" : 4,
	"kT_sampling_start" : 1,
	"kT_sampling_end" : 0.1,
	"n_steps_hold_start" : 100,
	"n_steps_hold_end" : 1000,
	"n_steps_linear_gradient" : 100
	}

Where:

* `pdb_in` is  a pdb file containing the input structure, which should be a Cn symmetric multimer.
* `pdb_out_folder` is the folder where output structures will be written
* `pdb_out_prefix` is used in the output filename in between the `pdb_in` filename and the output sequence number 
* `symm_file` is the rosetta symmetry file that turns the monomer (first chain of pdb_in) into the correct multimer structure
* `chargefile` is the rosetta charge file that constrains the net charge of the protein
* `comp_file` is the rosetta comp file that constrains the aminoacid composition of the protein
* `score_file` has the output scores
* `designable_residues` is the set of (surface) residues that can in principle be mutated.
* `exclude_residues` is the residueset to be excluded from the calculation of the averages of the electrostatic potential
* `repack_distance_treshold` residues within this distance (in Angstrom) from the residues to be mutated, will be repacked.
* `n_mutate` is the number of mutations per simulated annealing step, residues to be mutated are selected randomly from the `designable` residueset.
* `kT_sampling_start` . kT_sampling controls the fluctuations of the score allowed in the simulated annealing search, this is the starting value.
* `kT_sampling_end` final value of kT_sampling.
* `n_steps_hold_start`  number of initial steps at `kT_sampling_start`
* `n_steps_hold_end`  number of final steps at `kT_sampling_end`
* `n_steps_linear_gradient`  number of steps of linear gradient from `kT_sampling_start` to `kT_sampling_end`

	 
folders 
*******

* `input`  - Must have `chargedesign.json` inputfile
* `pdb` - Preferably, store input and output pdb files here, for example in subfolders `pdb/in` and `pdb/out`
* `constraints` - Preferred location for rosetta charge-constraint and composition constraint files `charge_file` and `comp_file`
* `apbs` - Anything related to pqr2pdb and apbs goes here. Apbs input parameters are in the template file `apbs/apbs_template.in`, which must already be present. The .pqr outputfiles of pqr2pdb, the .in inputfiles for apbs, the .log files of apbs the .dx outputfiles of apbs are all written to the apbs folder, and deleted when no longer needed. For calculating protein charges used by apbs, we call pdb2pqr with these flags: 

.. code-block:: console

		$ pdb2pqr30 --ff=AMBER --titration-state-method=propka --with-ph=7

	
* `docs` - Sphinx documentation.
*  `res` - Temporary rosetta resfiles generated by the script for doing the mutations and repacking are saved here. 
* `scores` - Preferred folder for output run scores. 
*  `sym` - Preferred folder for rosetta symmetry files
* `theory` - Folder with some further background information

"""

import pyrosetta
import json
import math
import string
import os
import sys
import numpy
import random
import argparse

# local
import potentials
import chargedesign_utilities

if __name__ == "__main__":

	print('\n ====> chargedesign setup: read & parse json input file\n')
	
	# cmdline args
	thisscript = "chargedesign: find surface residues that minimize fluctuations of surface electrostatic potential."
	parser = argparse.ArgumentParser(description = thisscript)
	parser.add_argument('json_in',  help = "json input file")
	args = parser.parse_args()

	# get input
	scriptname = os.path.basename(__file__).rsplit(".",maxsplit=1)[0]
	with open(args.json_in, 'r') as f:
		input = json.load(f)
		
	# parse input
	pdb_in = input["pdb_in"]
	pdb_out_folder = input["pdb_out_folder"]
	pdb_out_prefix = input["pdb_out_prefix"]
	symm_file = input["symm_file"]
	charge_file = input["charge_file"]
	comp_file = input["comp_file"]
	score_file = input["score_file"] 
	designable_residues = input["designable_residues"]
	exclude_residues = input["exclude_residues"]
	repack_distance_threshold = input["repack_distance_treshold"]
	n_mutate = input["n_mutate"]
	n_steps_hold_start = input["n_steps_hold_start"]
	n_steps_hold_end = input["n_steps_hold_end"]
	n_steps_linear_gradient = input["n_steps_linear_gradient"]
	kT_sampling_start = input["kT_sampling_start"]
	kT_sampling_end = input["kT_sampling_end"]
	
	# more filenames
	pdb_file_basename = os.path.basename(pdb_in).rsplit(".",maxsplit=1)[0]
	res_dir = "res"
	def res_file(n):
		return os.path.join(res_dir,pdb_file_basename+pdb_out_prefix+str(n)+".res")
	def pdb_out(n): 
		return os.path.join(pdb_out_folder,pdb_file_basename+pdb_out_prefix+str(n)+".pdb")

	# annealing profile
	def get_kT_sampling(n,n_steps_hold_start, n_steps_linear_gradient, n_steps_hold_end):
		delta_kT = kT_sampling_start - kT_sampling_end
		kT_step = delta_kT /float(n_steps_linear_gradient)
		dn = float(n - n_steps_hold_start)
		if n <= n_steps_hold_start:
			kT_sampling = kT_sampling_start
		elif n <= n_steps_hold_start + n_steps_linear_gradient:
			kT_sampling = kT_sampling_start - dn*kT_step
		else:
			kT_sampling = kT_sampling_end
		return kT_sampling
	
	print ("\n ====> chargedesign setup: Initialize pyRosetta \n")
	pyrosetta.init()
	
	print("\n ====>  chargedesign setup: get full atom score functions with and without charge/composition constraints \n")
	scorefxn = pyrosetta.get_fa_scorefxn()
	scorefxn.set_weight(pyrosetta.rosetta.core.scoring.netcharge, 1.0) # for NetChargeConstraintMover
	scorefxn.set_weight(pyrosetta.rosetta.core.scoring.aa_composition, 1.0) # for CompositionContraintMover
	scorefxn_noconstraints = pyrosetta.get_fa_scorefxn()

	print("\n ====>  chargedesign setup: get symmetric pose from pdb_in\n")
	pose_in =  pyrosetta.io.pose_from_pdb(pdb_in)
	n_chains = pose_in.num_chains()
	chargedesign_utilities.check_symmetry_file(pose_in, symm_file)
	
	# take the chain with rosetta chain number 1 as asymmetric unit
	pose_unit = pyrosetta.rosetta.core.pose.Pose()
	pyrosetta.rosetta.core.pose.append_pose_to_pose(pose_unit, pose_in.split_by_chain(1))
	n_res = pose_unit.total_residue() 
	
	# define symmetric poses
	pose = pyrosetta.rosetta.core.pose.Pose()
	pose_old = pyrosetta.rosetta.core.pose.Pose()
	pose.assign(pose_unit)
	symmetrize = pyrosetta.rosetta.protocols.symmetry.SetupForSymmetryMover(symm_file)
	symmetrize.apply(pose)
	pose_old.assign(pose)
	
	print("\n ===>  chargedesign setup: Set up NetChargeConstraintMover\n")
	charge_constraint = pyrosetta.rosetta.protocols.aa_composition.AddNetChargeConstraintMover()
	charge_constraint.create_constraint_from_file(charge_file)
	charge_constraint.apply(pose)

	print("\n ===>  chargedesign setup: Set up CompositionConstraintMover\n")
	composition_constraint = pyrosetta.rosetta.protocols.aa_composition.AddCompositionConstraintMover()
	composition_constraint.create_constraint_from_file(comp_file)
	composition_constraint.apply(pose)       

	print("\n ===>  chargedesign setup: initialize scores\n")

	# initialize scores
	n=0
	kT_sampling = kT_sampling_start
	scores =  chargedesign_utilities.get_scores(pose,pdb_out(n),exclude_residues,scorefxn_noconstraints,kT_sampling,n)
	scores_min = scores
	chargedesign_utilities.save_scores(score_file,scores,pdb_out(n),n)
	os.remove(pdb_out(n))
	
	print("\n ===>  chargedesign: start simulated annealing steps\n")
   	
	# start main loop 			
	n_total_steps = n_steps_hold_start + n_steps_linear_gradient + n_steps_hold_end
	for n in range(1,n_total_steps+1):
	
		# set sampling temperature
		kT_sampling = get_kT_sampling(n,n_steps_hold_start, n_steps_linear_gradient, n_steps_hold_end)
		print("\n ====> starting new step\n")
		print("...step number: ",n)
		print("...sampling temperature kT_sampling: ",kT_sampling)
		
		# save stuff from previous round
		scores_old = scores
		pose_old.assign(pose)
		
		print("\n ====> chargedesign annealing step: pick random residues to be mutated, find neighbouring residues for repacking, round "+str(n)+"\n")
		mutate = list(numpy.random.choice(designable_residues, size=n_mutate, replace=False))
		repack = chargedesign_utilities.find_neighbours(pose_unit,mutate,repack_distance_threshold)
		print("mutate = ", mutate)
		print("repack = ", repack)
		
		print("\n ====> chargedesign annealing step: setup and apply PackRotamersMover, round "+str(n)+"\n")
		chargedesign_utilities.write_resfile(res_file(n),repack,mutate)
		task_pack = pyrosetta.standard_packer_task(pose)
		pyrosetta.rosetta.core.pack.task.parse_resfile(pose, task_pack, res_file(n))
		packer = pyrosetta.rosetta.protocols.minimization_packing.PackRotamersMover(scorefxn, task_pack)
		packer.apply(pose) 
		pose.dump_pdb(pdb_out(n))
		os.remove(res_file(n))
		print("\n...PackRotamersMover done\n")
	
		print("\n ====> chargedesign annealing step: get scores and apply Metropolis acceptance criterium, round "+str(n)+"\n") 
		scores =  chargedesign_utilities.get_scores(pose,pdb_out(n),exclude_residues,scorefxn_noconstraints,kT_sampling,n)
		delta = scores["delta_psi_sq"] - scores_old["delta_psi_sq"]
		boltzmann = math.exp(-delta/kT_sampling)
		xi = random.random()
		if (delta < 0.0 or boltzmann > xi or n==1): 
			# accept: do nothing, first step (n==1) is always accepted. 
			pass
		else: 
			# reject: revert to old pose and old scores
			pose.assign(pose_old)
			pose.dump_pdb(pdb_out(n))
			scores = scores_old

		# new absolute minimum ?
		if (n==1):		# initialize minumum when n = 1
			scores_min = scores
		elif (scores["delta_psi_sq"] < scores_min["delta_psi_sq"]): 
			n_prev_min = scores_min["step"]
			os.remove(pdb_out(n_prev_min))
			scores_min = scores
			print("\n\n...new minimum delta_psi_sq =  ",scores_min["delta_psi_sq"],"mV^2\n\n")
		else:
			os.remove(pdb_out(n))

		print("\n ====> chargedesign annealing step done, saving results.\n") 
		chargedesign_utilities.save_scores(score_file,scores,pdb_out(n),n)
	
	print("done.") 


